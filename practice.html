<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Japanese Kana Practice</title>
  <link rel="stylesheet" href="assets/css/style.css" />
  <style>
    /* Override main styles for practice page */
    main {
      padding: 0 !important;
    }

    .main-content {
      display: flex;
      gap: 2rem;
      max-width: 1200px;
      margin: 2rem auto;
      padding: 0 2rem;
    }

    .category-sidebar {
      min-width: 200px;
      background: #f8f9fa;
      padding: 1.5rem;
      border-radius: 8px;
      height: fit-content;
      position: sticky;
      top: 2rem;
    }

    .category-sidebar h3 {
      margin-top: 0;
      margin-bottom: 1rem;
      font-size: 1.1rem;
    }

    .category-filter {
      display: flex;
      align-items: center;
      margin-bottom: 0.75rem;
    }

    .category-filter input[type="checkbox"] {
      margin-right: 0.5rem;
      cursor: pointer;
    }

    .category-filter label {
      cursor: pointer;
      user-select: none;
    }

    .practice-container {
      flex: 1;
      max-width: 600px;
    }

    .language-selector {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
    }

    .language-btn {
      padding: 0.75rem 1.5rem;
      background: #e0e0e0;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      font-size: 1rem;
      font-weight: bold;
    }

    .language-btn.active {
      background: #28a745;
      color: white;
    }

    .tabs {
      display: flex;
      gap: 1rem;
      margin-bottom: 2rem;
      justify-content: center;
    }

    .tab {
      padding: 0.75rem 1.5rem;
      background: #f0f0f0;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      font-size: 1rem;
    }

    .tab.active {
      background: #007bff;
      color: white;
    }

    .quiz-card {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      text-align: center;
    }

    .question {
      font-size: 3rem;
      margin-bottom: 2rem;
      font-weight: bold;
    }

    .hint {
      font-size: 1rem;
      color: #666;
      margin-bottom: 1rem;
    }

    .answer-input {
      width: 100%;
      padding: 1rem;
      font-size: 1.5rem;
      border: 2px solid #ddd;
      border-radius: 4px;
      text-align: center;
      margin-bottom: 1rem;
    }

    .answer-input.correct {
      border-color: #28a745;
      background-color: #d4edda;
    }

    .answer-input.incorrect {
      border-color: #dc3545;
      background-color: #f8d7da;
    }

    .feedback {
      margin: 1rem 0;
      font-size: 1.2rem;
      font-weight: bold;
    }

    .correct-answer {
      color: #28a745;
      margin: 0.5rem 0;
    }

    .difficulty-buttons {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      margin-top: 1rem;
    }

    .difficulty-btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
    }

    .btn-again { background: #dc3545; color: white; }
    .btn-hard { background: #ffc107; color: black; }
    .btn-good { background: #28a745; color: white; }
    .btn-easy { background: #17a2b8; color: white; }

    .stats {
      margin-top: 2rem;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 4px;
      text-align: center;
    }

    .kana-keyboard {
      margin-top: 1.5rem;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 8px;
      display: none;
    }

    .kana-keyboard.visible {
      display: block;
    }

    .keyboard-tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      justify-content: center;
    }

    .keyboard-tab {
      padding: 0.5rem 1rem;
      background: #e0e0e0;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      font-size: 0.9rem;
    }

    .keyboard-tab.active {
      background: #007bff;
      color: white;
    }

    .kana-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 0.5rem;
      max-width: 400px;
      margin: 0 auto;
    }

    .kana-key {
      padding: 1rem;
      background: white;
      border: 2px solid #ddd;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1.2rem;
      transition: all 0.2s;
    }

    .kana-key:hover {
      background: #e3f2fd;
      border-color: #007bff;
    }

    .kana-key:active {
      transform: scale(0.95);
    }

    .special-keys {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      margin-top: 1rem;
    }

    .special-key {
      padding: 0.5rem 1rem;
      background: #ff9800;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .special-key:hover {
      background: #f57c00;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Script Practice</h1>
      <nav>
        <ul>
          <li><a href="index.html">Home</a></li>
          <li><a href="art.html">Art Portfolio</a></li>
          <li><a href="publications.html">Publications</a></li>
          <li><a href="practice.html">Practice Area</a></li>
        </ul>
      </nav>
    </header>

    <main>
      <div class="main-content">
        <div class="category-sidebar">
          <h3>Categories</h3>
          <div id="categoryFilters"></div>
        </div>

        <div class="practice-container">
          <div class="language-selector" style="text-align: center; margin-bottom: 1.5rem;">
            <button class="language-btn active" data-language="japanese">Japanese</button>
            <button class="language-btn" data-language="greek">Greek</button>
          </div>

        <div class="tabs">
          <button class="tab active" data-mode-index="0"><span id="modeLabel1">From Kana</span></button>
          <button class="tab" data-mode-index="1"><span id="modeLabel2">From Latin Letters</span></button>
          <button class="tab" data-mode-index="2"><span id="modeLabel3">JSL → Kana</span></button>
          <button class="tab" data-mode-index="3"><span id="modeLabel4">Kana → JSL</span></button>
        </div>

        <div class="quiz-card">
          <div class="question" id="question"></div>
          <div id="questionImage" style="display: none; text-align: center; margin: 1rem 0;">
            <img id="questionImg" src="" alt="Handshape" style="max-width: 300px; height: auto;" />
          </div>
          <div id="answerImageContainer" style="display: none; text-align: center; margin: 1rem 0;">
            <div id="answerImages" style="display: flex; justify-content: center; flex-wrap: wrap; gap: 1rem;"></div>
          </div>
          <div class="hint" id="hint"></div>
          <input type="text" class="answer-input" id="answer" placeholder="Type your answer..." autocomplete="off" />
          <div style="text-align: center;">
            <button id="revealButton" style="display: none; padding: 1rem 2rem; font-size: 1.2rem; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 1rem 0;">Reveal Answer</button>
          </div>
          <div class="feedback" id="feedback"></div>
          <div class="correct-answer" id="correctAnswer"></div>
          <div class="difficulty-buttons" id="difficultyButtons" style="display: none;">
            <button class="difficulty-btn btn-again" data-difficulty="again">Again</button>
            <button class="difficulty-btn btn-hard" data-difficulty="hard">Hard</button>
            <button class="difficulty-btn btn-good" data-difficulty="good">Good</button>
            <button class="difficulty-btn btn-easy" data-difficulty="easy">Easy</button>
          </div>
        </div>

        <div id="kanaKeyboard" class="kana-keyboard">
          <div class="keyboard-tabs">
            <button class="keyboard-tab active" data-script="hiragana">Hiragana</button>
            <button class="keyboard-tab" data-script="katakana">Katakana</button>
          </div>
          <div id="kanaGrid" class="kana-grid"></div>
          <div class="special-keys">
            <button class="special-key" id="backspaceKey">Backspace</button>
            <button class="special-key" id="clearKey">Clear</button>
          </div>
        </div>

        <div class="stats">
          <p>Cards in queue: <span id="queueCount">0</span></p>
        </div>
        </div>
      </div>
    </main>

    <footer>
      <p>&copy; 2025 David Ludeke</p>
    </footer>
  </div>

  <script>
    let wordList = [];
    let allWords = [];
    let scriptMapping = {};
    let signLanguageMapping = {};
    let currentLanguage = 'japanese';
    let currentMode = 'script-to-romaji';
    let currentCard = null;
    let reviewQueue = [];
    let currentKeyboardScript = 'hiragana';
    let selectedCategories = new Set();

    // Language-specific configurations
    const languageConfig = {
      japanese: {
        scripts: ['hiragana', 'katakana'],
        wordFile: 'japanese-word-list.json',
        mappingFile: 'kana-mapping.json',
        signLanguageFile: null, // TODO: Add JSL when ready
        wordKey: 'kana',
        modeLabels: ['Kana → Latin', 'Latin → Kana', 'JSL → Kana', 'Kana → JSL'],
        modes: ['script-to-romaji', 'romaji-to-script', 'sign-to-script', 'script-to-sign']
      },
      greek: {
        scripts: ['lowercase', 'uppercase'],
        wordFile: 'greek-word-list.json',
        mappingFile: 'greek-mapping.json',
        signLanguageFile: 'gsl-handshapes-mapping.json',
        wordKey: 'greek',
        modeLabels: ['Greek → Latin', 'Latin → Greek', 'GSL → Greek', 'Greek → GSL'],
        modes: ['script-to-romaji', 'romaji-to-script', 'sign-to-script', 'script-to-sign']
      }
    };

    // Spaced repetition intervals (in number of cards)
    const intervals = {
      again: 1,
      hard: 3,
      good: 5,
      easy: 10
    };

    async function loadData(language = currentLanguage) {
      const config = languageConfig[language];
      try {
        const fetchPromises = [
          fetch(config.wordFile),
          fetch(config.mappingFile)
        ];

        // Add sign language fetch if available
        if (config.signLanguageFile) {
          fetchPromises.push(fetch(config.signLanguageFile));
        }

        const responses = await Promise.all(fetchPromises);
        const [wordsResponse, mappingResponse, signLanguageResponse] = responses;

        if (!wordsResponse.ok) {
          throw new Error(`Failed to fetch ${config.wordFile}: ${wordsResponse.status}`);
        }
        if (!mappingResponse.ok) {
          throw new Error(`Failed to fetch ${config.mappingFile}: ${mappingResponse.status}`);
        }

        const wordsData = await wordsResponse.json();
        allWords = wordsData.words;
        scriptMapping = await mappingResponse.json();

        // Load sign language mapping if available
        if (signLanguageResponse && signLanguageResponse.ok) {
          signLanguageMapping = await signLanguageResponse.json();
        } else {
          signLanguageMapping = {};
        }

        currentKeyboardScript = config.scripts[0];
        buildCategoryFilters();
        updateModeLabels();
        updateModeTabs();
        buildScriptKeyboard();
        filterWordsByCategory();
        initializeQueue();
        showNextCard();
      } catch (error) {
        console.error('Error loading data:', error);
        const errorMsg = `Failed to load ${language} data files.\n\nError: ${error.message}\n\nNote: If you're opening this file directly (file:// protocol), you need to run a local web server. Try:\n  python3 -m http.server 8000\nThen open: http://localhost:8000/practice.html`;
        alert(errorMsg);
      }
    }

    function updateModeLabels() {
      const config = languageConfig[currentLanguage];
      for (let i = 0; i < 4; i++) {
        const label = document.getElementById(`modeLabel${i + 1}`);
        if (label) {
          label.textContent = config.modeLabels[i] || '';
        }
      }
    }

    function updateModeTabs() {
      const config = languageConfig[currentLanguage];
      const tabs = document.querySelectorAll('.tab');

      tabs.forEach((tab, index) => {
        if (index < config.modes.length) {
          tab.style.display = 'inline-block';
          // Disable sign language modes if mapping not available
          if ((config.modes[index] === 'sign-to-script' || config.modes[index] === 'script-to-sign') && !config.signLanguageFile) {
            tab.style.opacity = '0.5';
            tab.style.cursor = 'not-allowed';
            tab.disabled = true;
          } else {
            tab.style.opacity = '1';
            tab.style.cursor = 'pointer';
            tab.disabled = false;
          }
        } else {
          tab.style.display = 'none';
        }
      });
    }

    function buildCategoryFilters() {
      // Extract all unique categories from words
      const categoriesSet = new Set();
      allWords.forEach(word => {
        if (word.categories) {
          word.categories.forEach(cat => categoriesSet.add(cat));
        }
      });

      const categories = Array.from(categoriesSet).sort();

      // Select all categories by default
      selectedCategories = new Set(categories);

      const filtersContainer = document.getElementById('categoryFilters');
      if (!filtersContainer) {
        console.error('categoryFilters element not found!');
        return;
      }

      filtersContainer.innerHTML = '';

      categories.forEach(category => {
        const filterDiv = document.createElement('div');
        filterDiv.className = 'category-filter';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `category-${category}`;
        checkbox.value = category;
        checkbox.checked = true;
        checkbox.addEventListener('change', handleCategoryChange);

        const label = document.createElement('label');
        label.htmlFor = `category-${category}`;
        label.textContent = category;

        filterDiv.appendChild(checkbox);
        filterDiv.appendChild(label);
        filtersContainer.appendChild(filterDiv);
      });
    }

    function handleCategoryChange(event) {
      const category = event.target.value;
      if (event.target.checked) {
        selectedCategories.add(category);
      } else {
        selectedCategories.delete(category);
      }
      filterWordsByCategory();
      initializeQueue();
      showNextCard();
    }

    function filterWordsByCategory() {
      if (selectedCategories.size === 0) {
        wordList = [];
        return;
      }

      wordList = allWords.filter(word => {
        if (!word.categories || word.categories.length === 0) {
          return false;
        }
        return word.categories.some(cat => selectedCategories.has(cat));
      });

      // Randomize the word list
      wordList = shuffleArray([...wordList]);
    }

    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    function initializeQueue() {
      reviewQueue = wordList.map((word, index) => ({
        ...word,
        id: index,
        nextReview: 0
      }));
      updateQueueCount();
    }

    function updateQueueCount() {
      document.getElementById('queueCount').textContent = reviewQueue.length;
    }

    function showNextCard() {
      if (reviewQueue.length === 0) {
        initializeQueue();
      }

      if (reviewQueue.length === 0) {
        // No words available for selected categories
        const questionEl = document.getElementById('question');
        questionEl.textContent = 'No words available. Please select at least one category.';
        return;
      }

      // Sort by nextReview and get the first card
      reviewQueue.sort((a, b) => a.nextReview - b.nextReview);
      currentCard = reviewQueue[0];

      const questionEl = document.getElementById('question');
      const hintEl = document.getElementById('hint');
      const answerEl = document.getElementById('answer');
      const feedbackEl = document.getElementById('feedback');
      const correctAnswerEl = document.getElementById('correctAnswer');
      const questionImageDiv = document.getElementById('questionImage');
      const questionImg = document.getElementById('questionImg');
      const revealButton = document.getElementById('revealButton');
      const answerImageContainer = document.getElementById('answerImageContainer');
      const answerImages = document.getElementById('answerImages');

      // Reset display
      answerEl.value = '';
      answerEl.className = 'answer-input';
      feedbackEl.textContent = '';
      correctAnswerEl.textContent = '';
      hintEl.textContent = '';
      questionImageDiv.style.display = 'none';
      questionImg.src = '';
      answerImageContainer.style.display = 'none';
      answerImages.innerHTML = '';
      revealButton.style.display = 'none';
      document.getElementById('difficultyButtons').style.display = 'none';
      document.getElementById('kanaKeyboard').classList.remove('visible');

      const config = languageConfig[currentLanguage];
      const scriptKey = config.wordKey;

      switch (currentMode) {
        case 'script-to-romaji':
          // Show script, answer with Latin letters
          questionEl.textContent = currentCard[scriptKey];
          questionEl.style.display = 'block';
          answerEl.style.display = 'block';
          answerEl.focus();
          break;

        case 'romaji-to-script':
          // Show Latin letters, answer with script
          questionEl.textContent = currentCard.romaji;
          questionEl.style.display = 'block';
          answerEl.style.display = 'block';
          document.getElementById('kanaKeyboard').classList.add('visible');
          answerEl.focus();
          break;

        case 'sign-to-script':
          // Show handshapes for each letter in word, answer with script
          if (signLanguageMapping.handshapes) {
            questionEl.style.display = 'none';
            const greekWord = currentCard[scriptKey];
            const handshapeImgs = getHandshapesForWord(greekWord);

            if (handshapeImgs.length > 0) {
              // Create a container for multiple handshapes
              answerImages.innerHTML = '';
              handshapeImgs.forEach(imgSrc => {
                const img = document.createElement('img');
                img.src = imgSrc;
                img.alt = 'Handshape';
                img.style.maxWidth = '150px';
                img.style.height = 'auto';
                answerImages.appendChild(img);
              });
              answerImageContainer.style.display = 'block';
              answerEl.style.display = 'block';
              // Show keyboard for Greek language
              if (currentLanguage === 'greek') {
                document.getElementById('kanaKeyboard').classList.add('visible');
              }
              answerEl.focus();
            }
          }
          break;

        case 'script-to-sign':
          // Show script, reveal handshapes
          questionEl.textContent = currentCard[scriptKey];
          questionEl.style.display = 'block';
          answerEl.style.display = 'none';
          revealButton.style.display = 'inline-block';
          break;
      }

      updateQueueCount();
    }

    function findHandshapeForLetter(romaji) {
      if (!signLanguageMapping.handshapes) return null;
      const letterName = romaji.toLowerCase();
      return signLanguageMapping.handshapes[letterName] || null;
    }

    function getHandshapesForWord(greekWord) {
      // Convert Greek word to array of letter names and get handshape images
      const handshapeImages = [];

      for (let char of greekWord) {
        // Map Greek letter to its romanized name
        const letterName = greekLetterToRomanName(char);
        if (letterName) {
          const handshape = signLanguageMapping.handshapes[letterName];
          if (handshape && handshape.image) {
            handshapeImages.push(handshape.image);
          }
        }
      }

      return handshapeImages;
    }

    function greekLetterToRomanName(greekChar) {
      // Map Greek letters (uppercase) to their romanized names
      const greekToRoman = {
        'Α': 'alpha', 'Β': 'beta', 'Γ': 'gamma', 'Δ': 'delta',
        'Ε': 'epsilon', 'Ζ': 'zeta', 'Η': 'eta', 'Θ': 'theta',
        'Ι': 'iota', 'Κ': 'kappa', 'Λ': 'lambda', 'Μ': 'mu',
        'Ν': 'nu', 'Ξ': 'xi', 'Ο': 'omicron', 'Π': 'pi',
        'Ρ': 'rho', 'Σ': 'sigma', 'Τ': 'tau', 'Υ': 'upsilon',
        'Φ': 'phi', 'Χ': 'chi', 'Ψ': 'psi', 'Ω': 'omega',
        // Lowercase versions
        'α': 'alpha', 'β': 'beta', 'γ': 'gamma', 'δ': 'delta',
        'ε': 'epsilon', 'ζ': 'zeta', 'η': 'eta', 'θ': 'theta',
        'ι': 'iota', 'κ': 'kappa', 'λ': 'lambda', 'μ': 'mu',
        'ν': 'nu', 'ξ': 'xi', 'ο': 'omicron', 'π': 'pi',
        'ρ': 'rho', 'σ': 'sigma', 'ς': 'sigma', 'τ': 'tau',
        'υ': 'upsilon', 'φ': 'phi', 'χ': 'chi', 'ψ': 'psi', 'ω': 'omega'
      };

      return greekToRoman[greekChar] || null;
    }

    function buildScriptKeyboard() {
      const kanaGrid = document.getElementById('kanaGrid');
      kanaGrid.innerHTML = '';

      const scriptChars = scriptMapping[currentKeyboardScript];

      if (scriptChars) {
        for (const [char, romaji] of Object.entries(scriptChars)) {
          const button = document.createElement('button');
          button.className = 'kana-key';
          button.textContent = char;
          button.dataset.char = char;
          button.addEventListener('click', (e) => {
            e.preventDefault();
            const answerInput = document.getElementById('answer');
            answerInput.value += char;
            // Don't call focus() to prevent page from jumping
          });
          kanaGrid.appendChild(button);
        }
      }

      // Update keyboard tabs
      const config = languageConfig[currentLanguage];
      const keyboardTabs = document.querySelectorAll('.keyboard-tab');
      keyboardTabs.forEach((tab, index) => {
        if (index < config.scripts.length) {
          tab.style.display = 'block';
          tab.textContent = config.scripts[index].charAt(0).toUpperCase() + config.scripts[index].slice(1);
          tab.dataset.script = config.scripts[index];
        } else {
          tab.style.display = 'none';
        }
      });
    }

    function checkAnswer() {
      const userAnswer = document.getElementById('answer').value.trim().toLowerCase();
      const answerEl = document.getElementById('answer');
      const feedbackEl = document.getElementById('feedback');
      const correctAnswerEl = document.getElementById('correctAnswer');
      const hintEl = document.getElementById('hint');

      const config = languageConfig[currentLanguage];
      const scriptKey = config.wordKey;

      let correctAnswer;
      let correctAnswerDisplay;
      if (currentMode === 'script-to-romaji') {
        correctAnswerDisplay = currentCard.romaji;
        correctAnswer = currentCard.romaji.toLowerCase();
      } else {
        correctAnswerDisplay = currentCard[scriptKey];
        correctAnswer = currentCard[scriptKey].toLowerCase();
      }

      const isCorrect = userAnswer === correctAnswer;

      // Show the English meaning after submission
      hintEl.textContent = `(${currentCard.english})`;

      if (isCorrect) {
        answerEl.className = 'answer-input correct';
        feedbackEl.textContent = '✓ Correct!';
        feedbackEl.style.color = '#28a745';
      } else {
        answerEl.className = 'answer-input incorrect';
        feedbackEl.textContent = '✗ Incorrect';
        feedbackEl.style.color = '#dc3545';
        correctAnswerEl.textContent = `Correct answer: ${correctAnswerDisplay}`;
      }

      document.getElementById('difficultyButtons').style.display = 'flex';
    }

    function handleDifficulty(difficulty) {
      const interval = intervals[difficulty];

      // Remove current card from queue
      reviewQueue.shift();

      // Calculate when this card should appear again
      currentCard.nextReview = interval;

      // Decrement all nextReview counters
      reviewQueue.forEach(card => {
        if (card.nextReview > 0) card.nextReview--;
      });

      // Add card back to queue
      reviewQueue.push(currentCard);

      showNextCard();
    }

    // Event listeners
    // Language selector
    document.querySelectorAll('.language-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = e.currentTarget;
        const newLanguage = button.dataset.language;

        // Only reload if language actually changed
        if (newLanguage !== currentLanguage) {
          document.querySelectorAll('.language-btn').forEach(b => b.classList.remove('active'));
          button.classList.add('active');
          currentLanguage = newLanguage;
          loadData(currentLanguage);
        }
      });
    });

    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', (e) => {
        const button = e.currentTarget;
        if (button.disabled) return;

        const modeIndex = parseInt(button.dataset.modeIndex);
        const config = languageConfig[currentLanguage];
        const newMode = config.modes[modeIndex];

        // Only update if mode actually changed
        if (newMode !== currentMode) {
          document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
          button.classList.add('active');
          currentMode = newMode;
          showNextCard();
        }
      });
    });

    document.getElementById('answer').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const diffButtons = document.getElementById('difficultyButtons');
        if (diffButtons.style.display === 'none') {
          checkAnswer();
        } else {
          handleDifficulty('good');
        }
      }
    });

    document.querySelectorAll('.difficulty-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        handleDifficulty(e.target.dataset.difficulty);
      });
    });

    // Keyboard tab switching
    document.querySelectorAll('.keyboard-tab').forEach(tab => {
      tab.addEventListener('click', (e) => {
        document.querySelectorAll('.keyboard-tab').forEach(t => t.classList.remove('active'));
        e.target.classList.add('active');
        currentKeyboardScript = e.target.dataset.script;
        buildScriptKeyboard();
      });
    });

    // Special keyboard keys
    document.getElementById('backspaceKey').addEventListener('click', (e) => {
      e.preventDefault();
      const answerInput = document.getElementById('answer');
      answerInput.value = answerInput.value.slice(0, -1);
      // Don't call focus() to prevent page from jumping
    });

    document.getElementById('clearKey').addEventListener('click', (e) => {
      e.preventDefault();
      const answerInput = document.getElementById('answer');
      answerInput.value = '';
      // Don't call focus() to prevent page from jumping
    });

    // Reveal button for sign language mode
    function revealHandshapes() {
      if (currentMode === 'script-to-sign') {
        const config = languageConfig[currentLanguage];
        const scriptKey = config.wordKey;
        const greekWord = currentCard[scriptKey];
        const handshapeImgs = getHandshapesForWord(greekWord);

        if (handshapeImgs.length > 0) {
          const answerImages = document.getElementById('answerImages');
          const answerImageContainer = document.getElementById('answerImageContainer');

          answerImages.innerHTML = '';
          handshapeImgs.forEach(imgSrc => {
            const img = document.createElement('img');
            img.src = imgSrc;
            img.alt = 'Handshape';
            img.style.maxWidth = '150px';
            img.style.height = 'auto';
            answerImages.appendChild(img);
          });

          answerImageContainer.style.display = 'block';
          document.getElementById('revealButton').style.display = 'none';
          document.getElementById('difficultyButtons').style.display = 'flex';
        }
      }
    }

    document.getElementById('revealButton').addEventListener('click', revealHandshapes);

    // Global keyboard handler for Enter and Space in script-to-sign mode
    document.addEventListener('keydown', (e) => {
      if (currentMode === 'script-to-sign') {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault(); // Prevent space from scrolling the page

          const revealButton = document.getElementById('revealButton');
          const diffButtons = document.getElementById('difficultyButtons');

          // If reveal button is visible, click it
          if (revealButton.style.display !== 'none' && revealButton.style.display !== '') {
            revealHandshapes();
          }
          // If difficulty buttons are visible, click "Good"
          else if (diffButtons.style.display === 'flex') {
            handleDifficulty('good');
          }
        }
      }
    });

    // Initialize
    loadData();
  </script>
</body>
</html>
